# 과제 1, 2, 3번 설명
## 1번 필수과제
<p>
먼저 난수를 생성해야 하기 때문에 random 모듈을 호출했는데, 랜덤한 정수만 만들면 되므로 
from random import randint를 사용해서 간단하게 난수를 생성하였습니다.></p>
<p>
  While문을 돌릴 경우에는 조건을 그냥 True로 설정한 것이 아니라, 변수를 넣어서 반복문을 작성했고, 
  답을 입력받을 때 input의 결과는 str이므로 int()를 이용해 정수형으로 변환해주었습니다.
</p>
<p>
  정답과 사용자의 답을 비교하여, 클 경우와 작을 경우는 경고문만 출력하여 다시 while문이 돌아 대답을
  받았고, 정답인 경우에는 정답 출력과 동시에 while 변수의 값을 바꾸어 반복문을 멈추었습니다.
</p>

## 1번 도전과제
<p>
  먼저 범위를 벗어날 경우 경고 메시지를 출력하고, 끝난 뒤 다시 여부를 정할 수 있게 했는데 경고
  메시지의 경우는 답변을 받을 때 적용돼야하므로 먼저 반복에 대한 것부터 작성해보았습니다.
</p>
<p>
  아까 while문을 이용해 게임을 실행했는데, 다시 시작하고 싶은 경우에는 같은 답으로 하는 것이 아니라
  다른 답으로 새로운 게임을 해야 하므로, 기존의 정답을 구하는 부분과 게임이 돌아가는 while문 밖에
  큰 while문을 하나 더 만들었습니다. 그리하여 게임이 끝났을 경우에 재시작을 선택하면,
  처음부터 정답을 새로 설정하며 게임 while문이 돌아가게 됩니다.
</p>
<p>
  범위 내의 수를 입력하게 하기 위해서, 답변 받는 부분을 새로운 while문 안에 넣어서 답변이 범위 안에
  있을 경우에만 다음으로 넘어가도록 했습니다. 
</p>
<p>
  마지막으로, 이 게임을 실행하기 위해서 인수를 입력할 필요가 없고 만약 여러가지 게임들 중에서 이 게임을
  선택했을 경우에 바로 호출해서 실행할 수 있게끔, 전체를 numbergame()라는 함수로 정의하였습니다. 
  게임을 하고 싶은 경우 numbergame()으로 호출하면 바로 실행 가능합니다.
</p>
  
## 2번 필수과제
<p>
  먼저 Person이라는 클래스를 정의하고, 이름 나이 성별을 입력받아야 하기 때문에 생성자에
  name, gender, age를 추가하였습니다. 그리고 이 정보들을 인스턴스 속성에 저장하고, 출력해야 하므로
  display(self)라는 함수를 정의했는데, 인스턴스의 정보들을 출력해야 하므로 매개변수로 self를 
  넣어주지 않을 경우 오류가 나게 됩니다.
</p>
<p>
  클래스 정의에 앞서, 객체 이름은 소문자로 만드는게 좋다고 들었습니다. 앞으로는 객체 이름을 소문자로
  지을 예정입니다.
  클래스를 정의한 다음, 객체를 생성해야 하는데 두 가지 방법을 사용해보았습니다.
</p>

### 객체를 생성하면서 바로 입력받는 경우
<p>
처음으로, 객체를 생성할 때 객체 내에 input을 넣는 경우입니다. 물론 변수에 저장한 다음 그 값을 대입하는
  것이 가장 편하고 보기 좋지만, 코드 길이를 줄일 수 있을 것 같기도 하고 바로 입력받으면서 생성이
  가능한지 궁금하여 시도해보았고, 결과는 된다 였습니다. 객체를 생성할 때, 입력하는 인자에 input을 넣어도
  그 값이 그대로 들어가게 됩니다. 결과도 잘 나오는 것을 확인 가능합니다.
</p>

### 입력값을 변수에 저장한 다음 객체 생성하기
<p>
  다음은 정석적인 방법으로, 변수에 input을 이용해 값을 저장한 다음 객체를 생성하는 것인데, 문제 없이
  결과가 나오며 위의 방법과 결과는 동일했습니다.
</p>

## 2번 도전과제
<p>
  도전과제에서는 유효성 검사와 나이에 대한 인사 메시지 출력인데, 클래스 정의 부분에서는 인사를 하는 함수
  greet(self)를 정의했습니다. 함수 이름을 지을 때는, 용도에 맞는 이름을 짓는 것이 가장 좋습니다.
  입력받는 나이에 따라 출력이 달라지므로 self를 입력했고, 조건문을 이용해 20세 이상과 미만으로 나누어 인사
  말을 출력하도록 했습니다.
</p>
<p>
  성별 유효성 검사를 해야한다는 것은, 입력값이 올바른지 아닌지 확인하고 다시 입력받기 위해 while문을
  사용해야 한다는 것인데, 이 경우에도 아까와 같은 두 가지 방법을 시도해보았습니다.
</p>

### 입력값을 변수에 저장한 다음 객체 생성하기

<p>
  이번에는 처음에 변수에 저장한 다음 객체를 생성했는데, 이 때 1번 문제와 같이 입력값이 male, female
  인 경우에만 반복문을 종료할 수 있게 하였습니다. 입력값이 제대로 입력되었다면, 객체를 생성할 수 있고 이 때 
  정보 출력과 인사 함수도 입력한 나이에 따라 잘 작동하는 것을 확인할 수 있었습니다.
</p>

### 객체를 생성하면서 바로 입력받는 경우

<p>
  이번 경우는 안 될 거라고 대충 예상은 하고 있었습니다. 값을 대입할 때 while문을 넣으면 오류가 날 것
  같았는데, 아니나 다를까 오류가 나서 방법을 생각해보다가 함수로 유효성 검사를 하면 되지 않을까 생각했고,
  값을 대입하면 되니 결과값을 return으로 해보자 시도를 했습니다. 그 결과 함수 안에서 유효성 결과가 잘
  작동하여 결과값이 잘 대입된 것을 확인할 수 있었습니다.
</p>
<p>
  이렇게 하여 이번에도 객체 내에서 값을 입력받아서 생성하고, 함수 호출까지 문제없이 마무리되었습니다.
</p>

## 3번 필수과제

<p>
  우선 데이터셋을 불러와야 하므로, pandas 라이브러리를 선언해주고 pd.read_excel을 이용해서 
  데이터프레임에 저장했는데, 데이터프레임의 이름을 지을 때도 df_crime처럼 대강의 의미를 넣어서
  지어보았습니다. 그 후에 df_crime.info()를 이용해서 데이터를 확인한 결과 데이터의 타입들과 총 32행
  이라는 사실을 알게 되었습니다.
</p>

### 함수를 이용해서 '관서명'행의 값에 따라 '구별'열에 값 입력하기

<p>
  먼저 정보를 dictionary의 형태로 area에 저장하여 나중에 편하게 사용할 수 있게 하였으며,
  df_crime['구별'] = ''로 열을 만들고 값을 비워놓았습니다. 그 뒤에, '관서명' 열의 값이 area
  딕셔너리 안에 있으면 그 딕셔너리의 키 값, 즉 그 관서의 구 값이 return되도록 했습니다.
</p>
<p>
  그 후에, 32행이므로 for row in range(32):로, <b>이 경우에는 인덱스가 정수</b>이므로 반복문을
  실행하여 각 행별로 관서명의 값을 확인해서 구별 열에 값을 입력했습니다. 이 결과 원하던 결과가 잘
  나왔습니다.
</p>
<p>
  이 경우에 피벗 테이블을 만들 때, 관서명 열 값이 유지되므로 .drop(columns = '관서명')을 이용해서 
  관서명 열을 없앤 다음 '구별'열을 인덱스, sum을 적용하여 피벗 테이블을 만들었습니다.
</p>

### 관서명을 인덱스로 해서 매핑하는 경우

<p>
  df_crime = df_crime.set_index('관서명') 코드를 작성해서 관서명을 인덱스로 설정했습니다.
  이 경우에, <b>각 행의 인덱스가 정수가 아니라 관서명</b>이므로 for 반복문의 index 값과
  area의 key를 비교해서 일치할 경우 value값을 '구별'열에 대입할 수 있도록 했습니다. 그리고 
  이때는 라벨이 인덱스이므로, 위치를 정할 때 df.iloc이 아닌, df.loc을 이용했습니다. df.iloc은
  인덱스가 정수일 경우만 사용이 가능하므로 유의해야 합니다.
</p>
<p>
  이 경우에 피벗 테이블을 만들 때, 관서명 열 값은 인덱스였고 인덱스를 새로 지정할 경우에 기존 인덱스가
  사라져서 관서명 열이 안보이기 때문에 굳이 제거하지 않아도 진행이 가능합니다. 그 후에 '구 없음'행을 
  제거하고 싶은데, '구별'열을 인덱스로 했기 때문에 인덱스가 '구 없음'인 행을 삭제하면 됩니다. 따라서 
  area_pivot.drop(index = '구 없음', inplace = True)로 해당 행을 삭제하였습니다.
</p>
<p>
  각 범죄 별 검거율은 검거 / 발생 이므로 df['열1'] = df['열2'] / df['열3']을 반복하여
  각 범죄별 검거율 값을 한번에 지정하였습니다. 필요없는 열을 삭제하는 경우에는, 같은 작업을 여러번 반복
  하는 것이 아니라 리스트 안에 삭제할 열을 모두 넣어서 df.drop(columns = [삭제할 열 리스트])
  로 한번에 제거했습니다.
</p>
<p>
  열 이름을 교체하는 경우에도, 계속 반복작업 하는 것이 아니라 {'열1' : '열2', '열3' : '열4'}처럼 
  딕셔너리를 하나 생성하여 df.rename({열이름딕셔너리})로 한번에 교체했습니다.
</p>

## 3번 도전과제

<p>
  먼저 pd.read_csv로 csv파일을 불러오고, df.set_index('구별')로 인덱스 지정하였으며, 데이터프레임
  은 의미를 알 수 있게 population으로 이름을 지었습니다. 3번 필수과제에서 데이터프레임의 인덱스는 
  '구별'이었고, 도전과제의 데이터프레임 인덱스 또한 '구별'이므로 df1.join(df2)를 하여 데이터프레임 
  병합을 실행하였습니다.
</p>
<p>
  마지막으로 데이터프레임을 정렬해야 하는데, df.sort_values()만 하면 저장이 되는 것이 아니므로, 꼭 
  저장을 해야 정렬된 데이터프레임이 유지가 됩니다. 그리고, '검거율' 열을 기준으로 내림차순이므로
  joined_df = joined_df.sort_values('검거율', ascending = False)로 검거율 열 기준, 
  ascending = False로 내림차순 정렬을 진행했습니다.
  joined_df = joined_df.sort_values('검거율') 그냥 이렇게 적을 경우에는, 뒤에 ascending = 
  True가 생략된 것으로, 이는 오름차순을 의미합니다.
</p>

### 이렇게 과제를 마무리했는데, 같은 결과값도 과정이 다양하므로 많은 방법을 사용해서 자유롭게 코드를 작성하도록 노력해보았습니다.
